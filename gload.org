#+EXPORT_FILE_NAME: /home/epos/Blog/templates/a_better_download_button.html
#+HTML_HEAD: {{data['css']}}
#+HTML: {{data['header']}}

* Gload: A better download button
** Why?
During the summer I got re-absorbed (addicted) to Genshin Impact again, through some ADHD-train of thought I got to thinking about distributing a program written to /help/ someone play Genshin Impact more efficiently.

This was influenced by some posts on Reddit about how terrible it was for non-programmers to download software from and use GitHub in general, so I got to thinking about the alternatives which we already have.
** How would you do it in 2022?
*** So how would I publish a program I wrote for common usage?
Previously ([[https://github.com/epos95/byggis.git][hint, hint]]) I have used ~cargo~ and its excellent
#+begin_src bash
cargo install <package>
#+end_src
functionality.

This works great! Cargo makes it easy to install and distribute Rust applications, the problem comes from the fact that it requires ~cargo~ to be installed, something which non-programmers often do not.
*** So what are some of the better alternatives?
There are of course file hosting sites such as [[https://sourceforge.net/][sourceforge]], but considering how the number 2 google search containing sourceforge is "sourceforge safe" I would not count this as a good alternative. (WARNING: Strictly personal opinion to justify this entire program.)

You could also host pre-compiled executable files for each operating system inside your git repository (or on any other file hosting service availible to the user), this poses issues in that the user would most likely need to choose which executable to download.
This can't be assumed to be true for a given user so I would not count this as a good alternative either.

** Finally introducing Gload:
Gload is the service I wrote in Rust to try and remedy the earlier mentioned problems! It is build around the scenario of some developer having some code they want to share effortlessly. It assumes that the dev has access to some sort of simple hosting for the Gload service but nothing else.

Gload grabs the users' CPU architecture to compute the target triple [link to rust docs here] for that computer and then cross compiles for that specific architecture and returns the program, all with minimal input from the user!

* Writing Gload
** The requirements for the program
- Be easy to use for anyone. Anyone should be able to use the service.
- Be aware of different user architectures. The service should make sure that the user gets the correct executable for the machine they are connecting from.
- Offload all the compilation from the user. The user should not have to install a compiler or toolchain to run or get the program on their computer.
- Utilize caching for the compiled files since re-compiling would take a loooong time.

** The technology used in the program
Since the specifications demanded minimal input from the user a webserver seemed like a great choice for hosting this service. The webserver space in Rust is very interesting with two of the most famous Rust webserver frameworks being in the top 10 fastest in the world according to [[https://www.techempower.com/benchmarks/#section=data-r21&test=composite][techempover.com]]. While speed was not critical for this service I had been seeing some talk about [[https://github.com/tokio-rs/axum][Axum]] on my Twitter timeline from the wonderful [[https://fasterthanli.me/https://fasterthanli.me/][fasterthanlime]] so I decided to try that.
Normally everything from the people at Tokio is /excellent/ and Axum is no exception, however I have always been a bit unfamiliar with the async ecosystem in Rust so this was a space I was happy to dive into more.

Gload also uses [[https://github.com/cross-rs/cross][Cross]] to reliably cross compile the binaries. Cross utilizes Docker and is great for when the normall cross compilation feature for cargo might run into linker issues. (I am sure that you can setup cargo with proper linkers and toolchain to reliably cross compile and this might be a point to improve if I revisit the program at a later point.)

To detect the architecture of the target machine I found [[http://jsfiddle.net/ChristianL/AVyND/][this fiddle]], which retrieved the relevant information, and in true programmer fashion, stole it. This let me get the target triple of the client reliably.

For the caching part of Gload I decided to write my own cache. This cache is very simply and is just a wrapper around a hashmap implementation of the programmers choice.

** Program architecture
*** The 0th iteration
While starting to write on Gload I first tested all the different components in a vacuum. This included proving that I could:
 - Return files with Axum.
 - Get relevant information through JS to guess a clients' architecture.
 - Cross compile files programmatically.
and since I was able to prove all of these I had all the simple parts to start building the program.

*** The next iteration
After having proved that the parts of the program worked I felt comfortable with investing more time since it meant that the complete program hopefully /should/ work (although this was a bit of a mistake on my part).
At this point I combined all of the parts of the project by building a minimalist axum server like so:

#+begin_src rust
// Imports omited
#[tokio::main]
async fn main() {
    // clone repo here

    let app = Router::new()
        .route("/:target_triple", get(get_binary));
    let addr = SocketAddr::from(([0,0,0,0], 3000));
    axum::Server::bind(&addr)
        .serve(app.into_make_service())
        .await
        .unwrap();
}

fn get_binary(Path(target_triple): Path<String>) -> impl IntoResponse {
    // assume repo exists
    Command::new("cross")
        .arg("b")
}
#+end_src

* Deeper implementation details

* Personal take-aways from the project
** Taking it a bit slower
When I have done projects in the past it has been a big loop of me throwing the project up on my github and then forgetting or losing interest. With Gload I did not throw it up on github instantly and instead played around untill I had a proof of concept and then some.
This was great since it let me take it less seriously and allowed me to back away from the project when needed to look at it from a different perspective instead of hyperfocusing.

** Synchronization primitives are honking great
